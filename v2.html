<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Three.js — Sphere with Ring (CDN-safe)</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0b0e11; }
    canvas { display: block; }
    #hud { position: fixed; top: 12px; left: 12px; padding: 8px 10px; color: #e8eef7; background: rgba(0,0,0,.45); border-radius: 8px; font: 13px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; white-space: pre-line; }
  </style>
  
  <!-- Import map fixes the "Failed to resolve module specifier 'three'" error
       by mapping bare specifiers to full URLs on a CDN. -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <div id="hud">Drag = orbit • Wheel = zoom • Right-drag = pan</div>
  <canvas id="c"></canvas>

  <script type="module">
    // --- Imports via import map (works locally and in sandboxes) ---
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const hud = document.getElementById('hud');
    const canvas = document.getElementById('c');

    // --- Renderer & Scene ---
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight, false);
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0e11);

    // --- Camera & Controls ---
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(5, 3, 7);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 0, 0);
    controls.enableDamping = true;

    // --- Lighting ---
    const key = new THREE.DirectionalLight(0xffffff, 1.1);
    key.position.set(5, 6, 4);
    const fill = new THREE.AmbientLight(0xffffff, 0.35);
    scene.add(key, fill);

    // --- Sphere (planet) ---
    const planetRadius = 2;
    const planetGeo = new THREE.SphereGeometry(planetRadius, 64, 64);
    const planetMat = new THREE.MeshStandardMaterial({ color: 0x4466ff, metalness: 0.1, roughness: 0.6, transparent: false });
    const planet = new THREE.Mesh(planetGeo, planetMat);
    planet.name = 'planet';
    scene.add(planet);

    // --- Ring (flat annulus around equator) ---
    // Inner radius slightly larger than the sphere to avoid z-fighting/intersection.
    const innerR = planetRadius * 1.05;  // just outside the sphere surface
    const outerR = planetRadius * 1.8;   // ring thickness

    const ringGeo = new THREE.RingGeometry(innerR, outerR, 128, 1);
    const ringMat = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      side: THREE.DoubleSide,
      metalness: 0.0,
      roughness: 0.9,
      transparent: false,     // keep opaque to avoid transparency sorting issues
      depthWrite: true,
      depthTest: true,
    });
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.name = 'mainRing';

    // Lay the ring in the XZ plane (i.e., around the Y axis / equator)
    ring.rotation.x = Math.PI / 2;

    // Ensure sphere draws before ring (not strictly necessary with opaque materials,
    // but keeps intent clear if you later add transparency/textures).
    planet.renderOrder = 0;
    ring.renderOrder = 1;

    scene.add(ring);

    // --- Optional: extra subtle bands, depth-safe ---
    const addBand = (r0, r1, opacity = 0.25) => {
      const g = new THREE.RingGeometry(r0, r1, 128);
      const m = new THREE.MeshStandardMaterial({
        color: 0xcfd8ff,
        side: THREE.DoubleSide,
        transparent: true,
        opacity,
        depthWrite: true,   // write depth so the planet properly occludes the band
        depthTest: true,
      });
      const mesh = new THREE.Mesh(g, m);
      mesh.rotation.x = Math.PI / 2;
      mesh.renderOrder = 1;
      return mesh;
    };
    scene.add(addBand(innerR * 1.05, innerR * 1.18, 0.35));
    scene.add(addBand(innerR * 1.22, innerR * 1.45, 0.25));
    scene.add(addBand(innerR * 1.50, innerR * 1.75, 0.2));

    // --- Resize handling ---
    function onResize() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onResize);

    // --- Animation loop ---
    const clock = new THREE.Clock();
    function render() {
      const t = clock.getElapsedTime();
      planet.rotation.y = t * 0.25;
      ring.rotation.z = t * 0.05; // gentle precession
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(render);
    }

    // --- Simple runtime self-tests ("test cases") ---
    function selfTests() {
      const tests = [];

      tests.push({
        name: 'THREE import',
        pass: typeof THREE.REVISION === 'string',
        detail: `REVISION=${THREE.REVISION}`
      });

      tests.push({
        name: 'Renderer attached to canvas',
        pass: renderer.domElement === canvas,
        detail: ''
      });

      const planetFound = scene.children.find(o => o.name === 'planet' && o.isMesh && o.geometry && o.geometry.type === 'SphereGeometry');
      tests.push({
        name: 'Planet mesh (SphereGeometry) exists',
        pass: !!planetFound,
        detail: planetFound ? 'OK' : 'Missing planet mesh'
      });

      const ringFound = scene.children.find(o => o.name === 'mainRing' && o.isMesh && o.geometry && o.geometry.type === 'RingGeometry');
      tests.push({
        name: 'Main ring mesh (RingGeometry) exists',
        pass: !!ringFound,
        detail: ringFound ? 'OK' : 'Missing ring mesh'
      });

      tests.push({
        name: 'Ring wraps outside sphere',
        pass: innerR > planetRadius,
        detail: `innerR=${innerR.toFixed(2)} > planetRadius=${planetRadius.toFixed(2)}`
      });

      // Summarize in HUD
      const summary = tests.map(t => `${t.pass ? '✅' : '❌'} ${t.name}${t.detail ? ' — ' + t.detail : ''}`).join('\n');
      hud.textContent = `Drag = orbit • Wheel = zoom • Right-drag = pan\n${summary}`;

      // Also log details to console for debugging
      console.table(tests.map(t => ({ Test: t.name, Pass: t.pass, Detail: t.detail })));
    }

    // Kick everything off
    onResize();
    selfTests();
    render();
  </script>
</body>
</html>